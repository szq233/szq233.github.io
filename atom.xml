<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Szq233&#39;s Blog</title>
  
  
  <link href="https://szq233.github.io/atom.xml" rel="self"/>
  
  <link href="https://szq233.github.io/"/>
  <updated>2021-06-03T22:33:30.230Z</updated>
  <id>https://szq233.github.io/</id>
  
  <author>
    <name>Szq233</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js中的arguments和...args</title>
    <link href="https://szq233.github.io/2021/06/04/js%E4%B8%AD%E7%9A%84arguments%E5%92%8C-args/"/>
    <id>https://szq233.github.io/2021/06/04/js%E4%B8%AD%E7%9A%84arguments%E5%92%8C-args/</id>
    <published>2021-06-03T21:20:54.000Z</published>
    <updated>2021-06-03T22:33:30.230Z</updated>
    
    <content type="html"><![CDATA[<p><em>概要：学习express中间件原理时候遇到的arguments对象和…args形参，从一脸懵逼到简单认识…</em></p><span id="more"></span><h2 id="引言：">引言：</h2><p>最近在学习express框架的中间件原理时候遇到了一系列问题，让我总算是明白了啥叫基础不牢，地动山摇😭。首先是学习视频中使用的以下传参和解析方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> slice = <span class="built_in">Array</span>.prototype.slice；</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> info = &#123;&#125;;</span><br><span class="line">    info.stack = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚看到时我是真的满脸问号，slice是从Array原型上提取的方法，这arguments是啥，找半天愣是没找着哪里传入的参数。</p><h2 id="了解过程1：">了解过程1：</h2><p>再搜遍百度后，发现原来这个参数是function自带的属性，是一个类数组对象，保存的是当前函数传入的参数，是一个函数本身就有的对象属性。那么问题又来了，一个对象怎么使用了数组的slice方法，再一遍搜索百度之后（学习就是面向百度的过程😆），发现，这个类数组对象有.length属性。可以使用数组的slice方法进行数组切片。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>但是，由于该arguments对象继承于Object.prototype，原生没有slice方法，所以需要从数组原型链上提取slice方法来使用，所以其实第一个代码示例中的<code>slice.call(arguments, 1);</code>就是将arguments对象转换成数组，并切片返回第二个元素开始的所有元素的数组。</p><h2 id="了解过程2：">了解过程2：</h2><p>了解了这些，我回过头来看代码，清晰了很多，但是又发现了一个与arguments很相似的参数，<code>(...args)</code>。我以前学过的知识的印象里，这东西叫三点语法，作用是可以接收未知数量的参数。由于这个语法是真的和arguments有关系，我在百度arguments的同时了解到了<code>...args</code>的全貌。</p><p>首先，这个语法是ES6引入的新语法，全名叫做rest parameters(剩余参数)，三个点后面是自定义的参数名，它接收后得到的是一个真正的数组，也确实可以使用来传入未知数量的参数，如下示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);<span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>这样的特性使得它可以替代arguments来实现一些功能。👍</p><p>但是，它既然叫做剩余参数，那么一定有其”剩余“的特性，如下示例代码可以说明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">a, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line">foo2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//[2, 3, 4]</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line">foo2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//[3, 4]</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br></pre></td></tr></table></figure><p>可以说明，剩余参数接收的是全部参数中未与形参对应传入的剩下的参数。</p><p>值得注意的是：</p><p>1、三点语法只能放在所有形参的最后，不然会错，因为它已经包揽了未与它之前形参对应的剩余参数，再整个形参来接收看看有没有剩下的参数岂不是看不起它了。😹</p><p>2、使用剩余参数后，函数的length属性会发生改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">foo.length; <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>说明，length不包含rest。</p><p>3、不能和arguments一起使用。</p><h2 id="了解过程3：">了解过程3：</h2><p>在演示所学的代码的时候，我发现三点语法还可以当做运算符来使用，实现如下的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...args);</span><br><span class="line">&#125;</span><br><span class="line">max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure><p>没错，对数组进行了解构，将[1, 2, 3]解构成了1,2,3，它可以将可遍历的数组，对象甚至是字符串进行解构，再进行赋值，就可以实现数组复制，对象复制，字符串转换数组等功能。</p><h2 id="结束语：">结束语：</h2><p>JavaScript基础知识内容太多了！😤😭</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;概要：学习express中间件原理时候遇到的arguments对象和…args形参，从一脸懵逼到简单认识…&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>遇到的函数内局部变量与全局变量的问题</title>
    <link href="https://szq233.github.io/2021/05/28/%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%86%85%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://szq233.github.io/2021/05/28/%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%86%85%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-28T13:06:50.000Z</published>
    <updated>2021-05-28T14:22:12.919Z</updated>
    
    <content type="html"><![CDATA[<p><em>概要：最近在网络上偶然看到的局部与全局变量的问题，发现自己也有点理解困难，便尝试分析下…</em></p><span id="more"></span><h3 id="🍀问题：">🍀问题：</h3><p>✋如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);</span><br><span class="line">    foo.n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);</span><br><span class="line">&#125;)(foo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.n);</span><br></pre></td></tr></table></figure><p>这个函数最终的结果是报错，因为立即执行函数括号前没有分号分隔赋值语句的”}“，导致语法错误。那么，如果确实有分号，语法正确的情况下，这些代码执行后会输出什么呢？往下修改演示代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//1</span></span><br><span class="line">    foo.n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//2</span></span><br><span class="line">&#125;)(foo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.n);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果:</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>第一次看到结果确实蛮奇怪的，那么接下来分析下造成该输出结果的原因。</p><h3 id="🍀分析：">🍀分析：</h3><h4 id="1、先注释部分代码，确认各变量的作用范围">1、先注释部分代码，确认各变量的作用范围</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// var foo;</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//1</span></span><br><span class="line">    <span class="comment">// foo.n = 3;</span></span><br><span class="line">    <span class="comment">// var foo = &#123;n:2&#125;;</span></span><br><span class="line">    <span class="comment">// console.log(foo.n);</span></span><br><span class="line">&#125;)(foo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.n);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这里可以看到立即执行函数在第8行代码接收了全局变量<code>foo = &#123;n:1&#125;</code>，可以确定第一个输出的<code>foo.n</code>确实为1。</p><h4 id="2、取消部分注释">2、取消部分注释</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// var foo;</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//1</span></span><br><span class="line">    foo.n = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// var foo = &#123;n:2&#125;;</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//3</span></span><br><span class="line">&#125;)(foo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.n);<span class="comment">//3</span></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这里可以看到在5行的<code>foo.n=3;</code>后，7行和10行输出结果都为3，说明<code>foo.n=3;</code>改变了全局变量</p><p>同时7行代码也是访问到了全局变量。注意：由于在取消3行的<code>//var foo;</code>注释后，输出结果不变，说明<code>var foo;</code>无法创建绑定为函数内部的局部变量的foo变量。</p><h4 id="3、取消全部注释，结果分析">3、取消全部注释，结果分析</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//1</span></span><br><span class="line">    foo.n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//2</span></span><br><span class="line">&#125;)(foo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.n);<span class="comment">//3</span></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这里可以看到，7行代码输出结果改变了，说明<code>var foo = &#123;n:2&#125;;</code>创建了绑定为函数内局部变量的foo变量，同时赋值该局部变量不影响全局变量，所以第10行代码输出的依旧是在函数未创建局部变量foo前第5行代码修改的全局变量的值：3。</p><p>4行代码输出1是立即执行函数<code>()(foo)</code>接收的全局变量<code>foo = &#123;n:1&#125;</code>；7行代码输出的是6行代码声明并赋值的局部变量<code>foo = &#123;n:2&#125;</code>；10行输出的是函数内第5行代码<code>foo.n =3;</code>修改后的全局变量。</p><h4 id="4、增加部分代码以验证分析">4、增加部分代码以验证分析</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">foo</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//1</span></span><br><span class="line">    foo.n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> foo = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*增加的代码*/</span></span><br><span class="line">    foo.n = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(foo.n);<span class="comment">//4</span></span><br><span class="line">&#125;)(foo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.n);<span class="comment">//1</span></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这里输出的结果可以看出：确实，在创建了函数作用域内局部变量foo后，<code>foo.n = 4;</code>修改的是局部变量，不影响全局变量。</p><p>注意：此时可以通过传入window对象来修改全局变量。</p><h3 id="🍀分析结束">🍀分析结束</h3><p>在存在传入局部作用域的全局变量的情况下，仅在声明同名变量的情况下，无法覆盖传入的全局变量，需要为其赋值才能以局部变量的形式覆盖传入的全局变量。</p><p>😉👌</p><p>感觉有点小问题。。。</p><p>😳💦</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;概要：最近在网络上偶然看到的局部与全局变量的问题，发现自己也有点理解困难，便尝试分析下…&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js中闭包的概念</title>
    <link href="https://szq233.github.io/2021/05/25/js%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://szq233.github.io/2021/05/25/js%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2021-05-24T23:14:34.000Z</published>
    <updated>2021-05-25T00:16:32.482Z</updated>
    
    <content type="html"><![CDATA[<p><em>概要：Js中闭包的概念…</em></p><span id="more"></span><h2 id="个人理解：">个人理解：</h2><h3 id="js中闭包的定义💬：">js中闭包的定义💬：</h3><p>一个函数及其对外部某几个参数的引用，形成的一个整体，可以称之为闭包。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">()(<span class="keyword">var</span> a = <span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//明显函数foo引用了foo函数外部的两个变量，这个函数和其引用的变量（环境）形成一个整体</span></span><br><span class="line"><span class="comment">//这样一个整体可以称之为闭包</span></span><br></pre></td></tr></table></figure><p>我之前在学习闭包的时候所参照的一些返回函数和内嵌函数的例子，那么这里也简单做个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;全局变量&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;局部变量&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">return</span> foo2();</span><br><span class="line">&#125;</span><br><span class="line">foo1();<span class="comment">//打印“局部变量”</span></span><br><span class="line"><span class="comment">//foo2函数和局部变量a参数形成了闭包</span></span><br><span class="line"><span class="comment">//foo1函数实际执行return的foo2函数，foo2与局部变量a形成闭包，所以打印的是局部变量而不是全局变量</span></span><br></pre></td></tr></table></figure><h3 id="那么为什么要这样使用闭包呢❓？">那么为什么要这样使用闭包呢❓？</h3><p>原因是避免全局变量的影响。在es6的let、const新关键字出现之前，javascript只有函数作用域的概念而没有块作用域的概念。使用局部变量则需要函数内部定义，而如何访问到函数内部定义的局部变量，这就是闭包的作用。</p><h3 id="闭包的作用😎：">闭包的作用😎：</h3><p>1、通过闭包可以访问局部变量</p><p>2、可以是局部变量驻留内存中，避免使用全局变量</p><h3 id="闭包的缺陷😐：">闭包的缺陷😐：</h3><p>由于闭包里作用域返回的局部变量资源不会被立刻销毁回收,所以可能会<strong>占用更多的内存</strong>;所以过度使用闭包会导致性能下降;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;概要：Js中闭包的概念…&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js中回调函数的概念</title>
    <link href="https://szq233.github.io/2021/05/25/js%E4%B8%AD%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://szq233.github.io/2021/05/25/js%E4%B8%AD%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2021-05-24T22:52:20.000Z</published>
    <updated>2021-05-25T09:51:03.768Z</updated>
    
    <content type="html"><![CDATA[<p><em>概要：Js中回调函数的概念…</em></p><span id="more"></span><h2 id="个人理解：">个人理解：</h2><h3 id="回调函数的定义：">回调函数的定义：</h3><p>将一个函数作为参数的形式传入另一个函数中，那么这个函数就是回调函数，另一个函数可以决定在何时何处调用这个传入的回调函数。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不传参示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数foo，callback是接收回调函数的形参，不一定命名为callback</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);<span class="comment">//打印a</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);<span class="comment">//打印b</span></span><br><span class="line">    callback();<span class="comment">//执行回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);<span class="comment">//打印c</span></span><br><span class="line">&#125;</span><br><span class="line">foo(f);<span class="comment">//执行foo函数，将f函数作为参数传入，f函数就是回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参示例</span></span><br><span class="line"><span class="keyword">var</span> param1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">param,callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//param是函数foo接收param1参数的形参</span></span><br><span class="line">    <span class="comment">//函数foo，callback是接收回调函数的形参，不一定命名为callback</span></span><br><span class="line">    <span class="keyword">let</span> param2 = <span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(param);<span class="comment">//打印param1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);<span class="comment">//打印b</span></span><br><span class="line">    callback(param2);<span class="comment">//执行回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//param为接收param2参数的形参</span></span><br><span class="line"><span class="built_in">console</span>.log(param)<span class="comment">//打印param2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(param1,f);<span class="comment">//执行foo函数，将param1传入，将f函数作为参数传入，f函数就是回调函数</span></span><br></pre></td></tr></table></figure><h3 id="javascript中回调函数的作用：">javascript中回调函数的作用：</h3><p>1、代码的功能执行位置更清晰</p><p>2、解决异步编程问题，使异步执行操作的执行顺序及先后变得可以控制。异步执行操作有：定时器、建立网络连接、读取网络流数据、向文件写入数据、Ajax提交、请求数据库服务，等等。</p><p>但是，过度的使用回调函数会产生回调地狱问题，因此promise和async、await是解决异步编程的更优方案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;概要：Js中回调函数的概念…&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正向代理与反向代理</title>
    <link href="https://szq233.github.io/2021/05/16/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://szq233.github.io/2021/05/16/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2021-05-16T02:50:38.000Z</published>
    <updated>2021-05-16T03:48:44.915Z</updated>
    
    <content type="html"><![CDATA[<p><em>概要：正向代理与反向代理的简述和区别…</em></p><span id="more"></span><h3 id="简述：">简述：</h3><h4 id="一、代理的概念：">一、代理的概念：</h4><p>类似于一个中介，在A和B的连接中间使用C作为中介，C就是一个代理，用于A，B直接连接的中间处理或是资源分配。</p><h4 id="二、正向代理：">二、正向代理：</h4><p>正向代理类似于一个跳板，A经过C跳板访问B的内容，例如国内客户端是无法直接访问外网内容，此时使用一个可以访问外网内容的跳板（正向代理服务器），实现外网内容访问。</p><p>简单来说是A可以访问C，C可以访问B、与B实现数据交换，A无法直接访问B，通过C可以实现A访问B。</p><p>正向代理的作用：</p><ol><li>客户端访问跳板</li><li>服务器资源缓存，加速客户端访问</li><li>访问授权，上网认证</li><li>可以记录客户端访问日志</li></ol><h4 id="三、反向代理：">三、反向代理：</h4><p>反向代理（Reverse Proxy）实际运行方式是以反向代理服务器来接受Internet上的连接请求，然后将代理的请求统一转发给内部网络上的服务器，服务器将请求的资源返回给Internet上对应发送连接请求的客户端。</p><p>反向代理的作用：</p><ol><li>反向代理服务器作为公网访问地址，web服务器置于内网，确保内网、服务器的安全。</li><li>负载均衡。</li></ol><h3 id="图解：">图解：</h3><h4 id="正向代理：">正向代理：</h4><p><img src="/2021/05/16/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt></p><h4 id="反向代理：">反向代理：</h4><p><img src="/2021/05/16/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt></p><h4 id="网络大神总结👍：">网络大神总结👍：</h4><p>正向代理：买票的黄牛</p><p>反向代理：租房的代理</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;概要：正向代理与反向代理的简述和区别…&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="服务器" scheme="https://szq233.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="服务器" scheme="https://szq233.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中__proto__与prototype</title>
    <link href="https://szq233.github.io/2021/05/03/js%E4%B8%AD-proto-%E4%B8%8Eprototype/"/>
    <id>https://szq233.github.io/2021/05/03/js%E4%B8%AD-proto-%E4%B8%8Eprototype/</id>
    <published>2021-05-02T18:02:37.000Z</published>
    <updated>2021-05-16T03:49:15.360Z</updated>
    
    <content type="html"><![CDATA[<p><em>概要：js中__proto__和prototype的区别与个人解读</em></p><span id="more"></span><h4 id="关于js中-proto-和prototype的说明">关于js中__proto__和prototype的说明</h4><h5 id="区别：">区别：</h5><p>__proto__是浏览器对实例化对象中[[prototype]]属性的命名，__proto__是属于对象的属性，prototype是属于函数对象的属性。</p><h5 id="功能：">功能：</h5><p>__proto__是访问prototype的入口。</p><h4 id="个人解读：">个人解读：</h4><h5 id="区别：-v2">区别：</h5><p>prototype可以理解为在函数（函数对象）上的一个名为原型对象的属性，这里的原型对象是命名和功能意义双重含义的，所以prototype是函数（函数对象）上的一个属性，保存原型对象，意义上也可以叫做原型对象。那么这个原型对象的内容是一些可以继承的属性和方法。而__proto__是对象上的一个属性，通过这个属性可以访问prototype这个函数对象上的属性里的内容，也就是说<code>对象.__proto__</code>指向构造该对象的<code>函数.prototype</code>。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">...</span>)</span>&#123;...&#125;; <span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> Fn1(...); <span class="comment">//new一个对象</span></span><br><span class="line">obj1.__proto__ === Fn1.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>当然，由于函数在js语言中也是对象，所以也有__proto__属性，指向构造该函数的函数的prototype，一次类推，这就形成了一条原型链，链子的尽头是Object.prototype为null，这个Object非泛指某一个对象，而是实际的构造所有对象的函数。</p><h5 id="补充：">补充：</h5><p>这里还要提一下construct这个属性，理解为构造器，该属性是函数，并挂载在函数的prototype属性上。每一个由函数构造而来的对象都有一个construct属性（继承于构造该对象的函数），该属性功能为访问（获取）构造该对象的构造函数，可以理解为<code>该构造函数.prototype.construct == 该构造函数</code>。<span style="color:red">该构造函数构造的对象.construct</span>继承自<span style="color:red">该构造函数.prototype.construct</span> == <span style="color:red">该构造函数</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;概要：js中__proto__和prototype的区别与个人解读&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关闭NexT主题动画导致侧边栏消失</title>
    <link href="https://szq233.github.io/2021/04/30/%E5%85%B3%E9%97%ADNexT%E4%B8%BB%E9%A2%98motion%E5%AF%BC%E8%87%B4%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1/"/>
    <id>https://szq233.github.io/2021/04/30/%E5%85%B3%E9%97%ADNexT%E4%B8%BB%E9%A2%98motion%E5%AF%BC%E8%87%B4%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1/</id>
    <published>2021-04-29T18:32:36.000Z</published>
    <updated>2021-05-02T18:05:40.328Z</updated>
    
    <content type="html"><![CDATA[<p><em>概要：关于Hexo的NexT主题关闭motion动画导致侧边栏消失的解决方法…</em></p><h6 id="more"><span id="more"></span></h6><h5 id="起因：">起因：</h5><p>最近上手Hexo搭建博客，顺利搭建博客并一眼相中NexT这类简约风格的主题样式。</p><p>最初，NexT主题因为搭载的 <a href="https://theme-next.js.org/animate">https://theme-next.js.org/animate</a>的CSS动画引擎，第一眼那丝滑的动画确实特别惹眼，但由于个人喜好极速简约，便在网络上搜索关闭NexT主题过渡动画的方法，按网络上说法将主题根目录下_config.yml文件的<code>motion： enable：true</code>修改为<code>enable：false</code>，确实完成了动画的关闭，但拥有小部件和头像功能的侧边栏消失。</p><p>花了段时间找问题，在打开浏览器调试功能时，发现.sidebar元素被赋予了<code>visiblity：hidden</code>属性，在修改为<code>visiblity：visible</code>后，侧边栏再次可见。于是尝试找样式源文件，最终解决问题。</p><h5 id="解决方法：">解决方法：</h5><p>因为我用的NexT主题的Pisces的scheme，其他类型的可以参照尝试解决，找到主题文件夹如下图路径中的_sidebar.styl文件，打开该文件。</p><p><img src="/2021/04/30/%E5%85%B3%E9%97%ADNexT%E4%B8%BB%E9%A2%98motion%E5%AF%BC%E8%87%B4%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1/03.png" alt></p><p>搜索visibility，将visibility: hidden;修改为visibility: visible;</p><p><img src="/2021/04/30/%E5%85%B3%E9%97%ADNexT%E4%B8%BB%E9%A2%98motion%E5%AF%BC%E8%87%B4%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1/04.png" alt></p><p>保存，执行hexo cl、hexo g、hexo d稍微等待一会，刷新博客，发现侧边栏可以正常显示</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;概要：关于Hexo的NexT主题关闭motion动画导致侧边栏消失的解决方法…&lt;/em&gt;&lt;/p&gt;
&lt;h6 id=&quot;more&quot;&gt;&lt;/h6&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://szq233.github.io/categories/Hexo/"/>
    
    <category term="NexT" scheme="https://szq233.github.io/categories/Hexo/NexT/"/>
    
    
    <category term="Hexo" scheme="https://szq233.github.io/tags/Hexo/"/>
    
    <category term="NexT" scheme="https://szq233.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript不同数据在内存中存储方式</title>
    <link href="https://szq233.github.io/2021/04/29/js%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://szq233.github.io/2021/04/29/js%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2021-04-29T14:44:01.000Z</published>
    <updated>2021-05-02T18:48:02.838Z</updated>
    
    <content type="html"><![CDATA[<p><em>概要：Js数据类型在内存中的存储形式…</em></p><span id="more"></span><h2 id="Js数据类型：">Js数据类型：</h2><ul><li>简单数据类型（基本数据类型）:Number、String、Boolean、Undefined、Null</li><li>复杂数据类型（引用数据类型）:Object、Array、Function</li></ul><h2 id="数据结构：">数据结构：</h2><ul><li>常用的数据结构：数组、栈、堆、列表、链表、图、树</li><li>Js上述两种数据类型使用两种数据结构：栈（先进后出）、堆（特殊的树形结构）</li></ul><h2 id="数据存储方式：">数据存储方式：</h2><h3 id="1、简单数据类型：">1、简单数据类型：</h3><p>​简单数据类型保存在栈中，这些类型在内存中别占有固定大小，他们的值保存在栈空间，按值访问。变量在声明过程中，会在栈中开辟一段内存空间，变量值直接存在该内存中，变量读写的是它们实际保存的值。</p><img src="/2021/04/29/js%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/01.png" class><p>​简单数据数据复制时，会为新声明的变量直接开辟一段新空间， 然后把值复制到为新变量分配的空间中</p><p>​简单数据类在当前执行环境结束时销毁。</p><h3 id="2、复杂数据类型：">2、复杂数据类型：</h3><p>​复杂数据类型是不固定大小的数据，但是存放他们的地址大小是固定的，所以把地址保存在栈中，值保存在堆中。复杂数据类型是一个指针，指针保存在栈中，但是指针指向的是堆。即存储复杂数据类型的变量保存在栈中，数据本身保存在堆中。读取其数据时，先访问栈中的地址，通过地址找到存在堆中的数据。</p><p><img src="/2021/04/29/js%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/02.png" alt></p><p>​复杂数据类型在进行拷贝的时候，分为深拷贝和浅拷贝：<br>​浅拷贝：复制的是引用地址，所以拷贝的变量存储的引用地址和原来的指向堆中同一个地址。</p><p>​深拷贝：栈中开辟一段新的空间存储复制的变量，堆中开辟一个新的空间存储复制的内容，栈中变量存储的引用地址指向堆中复制的一个新的地址。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;概要：Js数据类型在内存中的存储形式…&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://szq233.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>newpagename2</title>
    <link href="https://szq233.github.io/2021/04/28/newpagename2/"/>
    <id>https://szq233.github.io/2021/04/28/newpagename2/</id>
    <published>2021-04-28T04:49:15.000Z</published>
    <updated>2021-04-28T04:50:19.985Z</updated>
    
    <content type="html"><![CDATA[<p>测试2测试2测试2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;测试2测试2测试2&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="测试" scheme="https://szq233.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>newpagename</title>
    <link href="https://szq233.github.io/2021/04/27/newpagename/"/>
    <id>https://szq233.github.io/2021/04/27/newpagename/</id>
    <published>2021-04-27T10:57:24.000Z</published>
    <updated>2021-04-28T04:50:11.867Z</updated>
    
    <content type="html"><![CDATA[<p>测试测试测试测试</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;测试测试测试测试&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="测试" scheme="https://szq233.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://szq233.github.io/2021/04/27/hello-world/"/>
    <id>https://szq233.github.io/2021/04/27/hello-world/</id>
    <published>2021-04-27T09:38:55.496Z</published>
    <updated>2021-04-27T15:22:17.191Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello World&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
