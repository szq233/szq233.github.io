<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/27/hello-world/</url>
    <content><![CDATA[<p>Hello World</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript中__proto__与prototype</title>
    <url>/2021/05/03/js%E4%B8%AD-proto-%E4%B8%8Eprototype/</url>
    <content><![CDATA[<p><em>概要：js中__proto__和prototype的区别与个人解读</em></p>
<span id="more"></span>
<h4 id="关于js中-proto-和prototype的说明">关于js中__proto__和prototype的说明</h4>
<h5 id="区别：">区别：</h5>
<p>__proto__是浏览器对实例化对象中[[prototype]]属性的命名，__proto__是属于对象的属性，prototype是属于函数对象的属性。</p>
<h5 id="功能：">功能：</h5>
<p>__proto__是访问prototype的入口。</p>
<h4 id="个人解读：">个人解读：</h4>
<h5 id="区别：-v2">区别：</h5>
<p>prototype可以理解为在函数（函数对象）上的一个名为原型对象的属性，这里的原型对象是命名和功能意义双重含义的，所以prototype是函数（函数对象）上的一个属性，保存原型对象，意义上也可以叫做原型对象。那么这个原型对象的内容是一些可以继承的属性和方法。而__proto__是对象上的一个属性，通过这个属性可以访问prototype这个函数对象上的属性里的内容，也就是说<code>对象.__proto__</code>指向构造该对象的<code>函数.prototype</code>。</p>
<p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params">...</span>)</span>&#123;...&#125;; <span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> Fn1(...); <span class="comment">//new一个对象</span></span><br><span class="line">obj1.__proto__ === Fn1.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>当然，由于函数在js语言中也是对象，所以也有__proto__属性，指向构造该函数的函数的prototype，一次类推，这就形成了一条原型链，链子的尽头是Object.prototype为null，这个Object非泛指某一个对象，而是实际的构造所有对象的函数。</p>
<h5 id="补充：">补充：</h5>
<p>这里还要提一下construct这个属性，理解为构造器，该属性是函数，并挂载在函数的prototype属性上。每一个由函数构造而来的对象都有一个construct属性（继承于构造该对象的函数），该属性功能为访问（获取）构造该对象的构造函数，可以理解为<code>该构造函数.prototype.construct == 该构造函数</code>。<span style="color:red">该构造函数构造的对象.construct</span>继承自<span style="color:red">该构造函数.prototype.construct</span> == <span style="color:red">该构造函数</span></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript不同数据在内存中存储方式</title>
    <url>/2021/04/29/js%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><em>概要：Js数据类型在内存中的存储形式…</em></p>
<span id="more"></span>
<h2 id="Js数据类型：">Js数据类型：</h2>
<ul>
<li>简单数据类型（基本数据类型）:Number、String、Boolean、Undefined、Null</li>
<li>复杂数据类型（引用数据类型）:Object、Array、Function</li>
</ul>
<h2 id="数据结构：">数据结构：</h2>
<ul>
<li>常用的数据结构：数组、栈、堆、列表、链表、图、树</li>
<li>Js上述两种数据类型使用两种数据结构：栈（先进后出）、堆（特殊的树形结构）</li>
</ul>
<h2 id="数据存储方式：">数据存储方式：</h2>
<h3 id="1、简单数据类型：">1、简单数据类型：</h3>
<p>​	简单数据类型保存在栈中，这些类型在内存中别占有固定大小，他们的值保存在栈空间，按值访问。变量在声明过程中，会在栈中开辟一段内存空间，变量值直接存在该内存中，变量读写的是它们实际保存的值。</p>
<img src="/2021/04/29/js%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/01.png" class>
<p>​	简单数据数据复制时，会为新声明的变量直接开辟一段新空间， 然后把值复制到为新变量分配的空间中</p>
<p>​	简单数据类在当前执行环境结束时销毁。</p>
<h3 id="2、复杂数据类型：">2、复杂数据类型：</h3>
<p>​	复杂数据类型是不固定大小的数据，但是存放他们的地址大小是固定的，所以把地址保存在栈中，值保存在堆中。复杂数据类型是一个指针，指针保存在栈中，但是指针指向的是堆。即存储复杂数据类型的变量保存在栈中，数据本身保存在堆中。读取其数据时，先访问栈中的地址，通过地址找到存在堆中的数据。</p>
<p><img src="/2021/04/29/js%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/02.png" alt></p>
<p>​	复杂数据类型在进行拷贝的时候，分为深拷贝和浅拷贝：<br>
​			浅拷贝：复制的是引用地址，所以拷贝的变量存储的引用地址和原来的指向堆中同一个地址。</p>
<p>​	深拷贝：栈中开辟一段新的空间存储复制的变量，堆中开辟一个新的空间存储复制的内容，栈中变量存储的引用地址指向堆中复制的一个新的地址。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>newpagename</title>
    <url>/2021/04/27/newpagename/</url>
    <content><![CDATA[<p>测试测试测试测试</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>newpagename2</title>
    <url>/2021/04/28/newpagename2/</url>
    <content><![CDATA[<p>测试2测试2测试2</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭NexT主题动画导致侧边栏消失</title>
    <url>/2021/04/30/%E5%85%B3%E9%97%ADNexT%E4%B8%BB%E9%A2%98motion%E5%AF%BC%E8%87%B4%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1/</url>
    <content><![CDATA[<p><em>概要：关于Hexo的NexT主题关闭motion动画导致侧边栏消失的解决方法…</em></p>
<h6 id="more"><span id="more"></span></h6>
<h5 id="起因：">起因：</h5>
<p>最近上手Hexo搭建博客，顺利搭建博客并一眼相中NexT这类简约风格的主题样式。</p>
<p>最初，NexT主题因为搭载的 <a href="https://theme-next.js.org/animate">https://theme-next.js.org/animate</a>的CSS动画引擎，第一眼那丝滑的动画确实特别惹眼，但由于个人喜好极速简约，便在网络上搜索关闭NexT主题过渡动画的方法，按网络上说法将主题根目录下_config.yml文件的<code>motion： enable：true</code>修改为<code>enable：false</code>，确实完成了动画的关闭，但拥有小部件和头像功能的侧边栏消失。</p>
<p>花了段时间找问题，在打开浏览器调试功能时，发现.sidebar元素被赋予了<code>visiblity：hidden</code>属性，在修改为<code>visiblity：visible</code>后，侧边栏再次可见。于是尝试找样式源文件，最终解决问题。</p>
<h5 id="解决方法：">解决方法：</h5>
<p>因为我用的NexT主题的Pisces的scheme，其他类型的可以参照尝试解决，找到主题文件夹如下图路径中的_sidebar.styl文件，打开该文件。</p>
<p><img src="/2021/04/30/%E5%85%B3%E9%97%ADNexT%E4%B8%BB%E9%A2%98motion%E5%AF%BC%E8%87%B4%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1/03.png" alt></p>
<p>搜索visibility，将visibility: hidden;修改为visibility: visible;</p>
<p><img src="/2021/04/30/%E5%85%B3%E9%97%ADNexT%E4%B8%BB%E9%A2%98motion%E5%AF%BC%E8%87%B4%E4%BE%A7%E8%BE%B9%E6%A0%8F%E6%B6%88%E5%A4%B1/04.png" alt></p>
<p>保存，执行hexo cl、hexo g、hexo d稍微等待一会，刷新博客，发现侧边栏可以正常显示</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理与反向代理</title>
    <url>/2021/05/16/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p><em>概要：正向代理与反向代理的简述和区别…</em></p>
<span id="more"></span>
<h3 id="简述：">简述：</h3>
<h4 id="一、代理的概念：">一、代理的概念：</h4>
<p>类似于一个中介，在A和B的连接中间使用C作为中介，C就是一个代理，用于A，B直接连接的中间处理或是资源分配。</p>
<h4 id="二、正向代理：">二、正向代理：</h4>
<p>正向代理类似于一个跳板，A经过C跳板访问B的内容，例如国内客户端是无法直接访问外网内容，此时使用一个可以访问外网内容的跳板（正向代理服务器），实现外网内容访问。</p>
<p>简单来说是A可以访问C，C可以访问B、与B实现数据交换，A无法直接访问B，通过C可以实现A访问B。</p>
<p>正向代理的作用：</p>
<ol>
<li>客户端访问跳板</li>
<li>服务器资源缓存，加速客户端访问</li>
<li>访问授权，上网认证</li>
<li>可以记录客户端访问日志</li>
</ol>
<h4 id="三、反向代理：">三、反向代理：</h4>
<p>反向代理（Reverse Proxy）实际运行方式是以反向代理服务器来接受Internet上的连接请求，然后将代理的请求统一转发给内部网络上的服务器，服务器将请求的资源返回给Internet上对应发送连接请求的客户端。</p>
<p>反向代理的作用：</p>
<ol>
<li>反向代理服务器作为公网访问地址，web服务器置于内网，确保内网、服务器的安全。</li>
<li>负载均衡。</li>
</ol>
<h3 id="图解：">图解：</h3>
<h4 id="正向代理：">正向代理：</h4>
<p><img src="/2021/05/16/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt></p>
<h4 id="反向代理：">反向代理：</h4>
<p><img src="/2021/05/16/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt></p>
<h4 id="网络大神总结👍：">网络大神总结👍：</h4>
<p>正向代理：买票的黄牛</p>
<p>反向代理：租房的代理</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>js中回调函数的概念</title>
    <url>/2021/05/25/js%E4%B8%AD%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><em>概要：Js中回调函数的概念…</em></p>
<span id="more"></span>
<h2 id="个人理解：">个人理解：</h2>
<h3 id="回调函数的定义：">回调函数的定义：</h3>
<p>将一个函数作为参数的形式传入另一个函数中，那么这个函数就是回调函数，另一个函数可以决定在何时何处调用这个传入的回调函数。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不传参示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数foo，callback是接收回调函数的形参，不一定命名为callback</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);<span class="comment">//打印a</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);<span class="comment">//打印b</span></span><br><span class="line">    callback();<span class="comment">//执行回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);<span class="comment">//打印c</span></span><br><span class="line">&#125;</span><br><span class="line">foo(f);<span class="comment">//执行foo函数，将f函数作为参数传入，f函数就是回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参示例</span></span><br><span class="line"><span class="keyword">var</span> param1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">param,callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//param是函数foo接收param1参数的形参</span></span><br><span class="line">    <span class="comment">//函数foo，callback是接收回调函数的形参，不一定命名为callback</span></span><br><span class="line">    <span class="keyword">let</span> param2 = <span class="string">&quot;c&quot;</span></span><br><span class="line">	<span class="built_in">console</span>.log(param);<span class="comment">//打印param1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);<span class="comment">//打印b</span></span><br><span class="line">    callback(param2);<span class="comment">//执行回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//param为接收param2参数的形参</span></span><br><span class="line">	<span class="built_in">console</span>.log(param)<span class="comment">//打印param2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(param1,f);<span class="comment">//执行foo函数，将param1传入，将f函数作为参数传入，f函数就是回调函数</span></span><br></pre></td></tr></table></figure>
<h3 id="javascript中回调函数的作用：">javascript中回调函数的作用：</h3>
<p>1、代码执行顺序逻辑更加清晰</p>
<p>2、解决异步编程问题，使异步执行操作的执行顺序及先后变得可以控制。异步执行操作有：定时器、建立网络连接、读取网络流数据、向文件写入数据、Ajax提交、请求数据库服务，等等。</p>
<p>目前，promise和async、await是解决异步编程的更优方案</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js中闭包的概念</title>
    <url>/2021/05/25/js%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><em>概要：Js中闭包的概念…</em></p>
<span id="more"></span>
<h2 id="个人理解：">个人理解：</h2>
<h3 id="js中闭包的定义💬：">js中闭包的定义💬：</h3>
<p>一个函数及其对外部某几个参数的引用，形成的一个整体，可以称之为闭包。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">()(<span class="keyword">var</span> a = <span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//明显函数foo引用了foo函数外部的两个变量，这个函数和其引用的变量（环境）形成一个整体</span></span><br><span class="line"><span class="comment">//这样一个整体可以称之为闭包</span></span><br></pre></td></tr></table></figure>
<p>我之前在学习闭包的时候所参照的一些返回函数和内嵌函数的例子，那么这里也简单做个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;全局变量&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="string">&quot;局部变量&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">return</span> foo2();</span><br><span class="line">&#125;</span><br><span class="line">foo1();<span class="comment">//打印“局部变量”</span></span><br><span class="line"><span class="comment">//foo2函数和局部变量a参数形成了闭包</span></span><br><span class="line"><span class="comment">//foo1函数实际执行return的foo2函数，foo2与局部变量a形成闭包，所以打印的是局部变量而不是全局变量</span></span><br></pre></td></tr></table></figure>
<h3 id="那么为什么要这样使用闭包呢❓？">那么为什么要这样使用闭包呢❓？</h3>
<p>原因是避免全局变量的影响。在es6的let、const新关键字出现之前，javascript只有函数作用域的概念而没有块作用域的概念。使用局部变量则需要函数内部定义，而如何访问到函数内部定义的局部变量，这就是闭包的作用。</p>
<h3 id="闭包的作用😎：">闭包的作用😎：</h3>
<p>1、通过闭包可以访问局部变量</p>
<p>2、可以是局部变量驻留内存中，避免使用全局变量</p>
<h3 id="闭包的缺陷😐：">闭包的缺陷😐：</h3>
<p>由于闭包里作用域返回的局部变量资源不会被立刻销毁回收,所以可能会<strong>占用更多的内存</strong>;所以过度使用闭包会导致性能下降;</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
